/**
 * @module  Terrain
 * @brief	Terrain procedural generation. This terrain is generated by using a normal
 *          plane with the indicated number of vertices, and offseting the height by
 *          using an octave perlin noise function
 *
 * @author	Roberto Cano (http://www.robertocano.es)
 */
#pragma once

#include <stdint.h>
#include <glm/glm.hpp>
#include "Asset3D.hpp"

namespace Procedural
{
/**
 * Terrain class to generate axis aligned planes
 */
class Terrain : public Asset3D
{
  public:
      /**
       * Constructor
       *
       * @param width   Width of the plane along the x-axis
       * @param depth   Depth of the plane along the z-axis
       * @param height  Maximum height of the terrain along the y-axis
       * @param slice   Slice number for the perlin noise function. This parameter can be used
       *                to generate the same terrain twice if needed
       * @param color   Default color for the plane material
       * @param angle   Bending angle for the plane. If 0.0f then a flat plane is generated,
       *                otherwise the plane is bent around the z-axis preserving its width on an
       *                arc indicated by 'angle'
       * @param numVertsWidth  Number of vertices to generate along the x-axis
       * @param numVertsHeight Number of vertices to generate along the y-axis
       * @param complexity     Number of composite frequencies that will conform the
       *                       terrain heights. This is done by using an octaves composition
       *                       of the perlin noise function
       * @pararm persistence   This parameter determines how important are the lower or the
       *                       higher frequencies for complexities highers than 1. If persistence
       *                       is less than 1.0f then the lower frequencies will have more impact
       *                       on the terrain heights. With a value higher than 1.0f the higher
       *                       frequencies will have a higher impact
       */
    Terrain(float width = 1.0f, float depth = 1.0f, float height = 1.0f,
            uint32_t slice = 0, const glm::vec3 &color = glm::vec3(1.0f, 1.0f, 1.0f),
          uint32_t numVertsWidth = 2, uint32_t numVertsDepth = 2,
          uint32_t complexity = 5, float persistence = 0.5f);

    /**
     * Accessors
     */
    float getWidth() const { return _width; }
    float getHeight() const { return _height; }
    const glm::vec3 &getColor() const { return _color; }
    uint32_t getNumVertsWidth() const { return _numVertsWidth; }
    uint32_t getNumVertsDepth() const { return _numVertsDepth; }

  private:
    float _width;
    float _depth;
    float _height;
    uint32_t _slice;
    glm::vec3 _color;
    uint32_t _numVertsWidth;
    uint32_t _numVertsDepth;
};
};
